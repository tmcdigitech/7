[{"body":"Let’s get something happening on your Gemma.\nAll of these examples are complete programs, so make sure you copy them into Mu (or whatever editor you’re using) and run them as you go through this page.\nFlash the built-in LED The first thing you try to get working on any embedded system is flashing a light. It’s amazing how much information you can convey with just a light if you get a little creative!\n1 2 3 4 5 6 7 8 9 10 11 12 import board import digitalio import time led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT while True: led.value = True time.sleep(0.5) led.value = False time.sleep(0.5) Lines 1-3 import various libraries that we will use. All of your Gemma programs will start with one or more of these import lines.\nLine 5 gives us a reference to the pin that the built-in LED (the red one) is connected to. We store that reference in a variable called led. Line 6 tells the Gemma that we want to use the pin we’ve called led as an output (to drive the red LED).\nLines 8-12 are an infinite loop. We turn the LED on, wait for half a second, turn it off, and wait another half second. Then we do it all again, and again, and so on.\nNote that time.sleep() takes values in seconds, rather than milliseconds. If you’ve written this in Mu, it should look like this:\nFlash the built-in RGB LED Now we’ve got something happening, let’s explore the built-in RGB LED. This model of LED is a Dotstar. The LEDs on the strip we’ll be using are a model called Neopixel.\n1 2 3 4 5 6 7 8 9 10 11 import board import adafruit_dotstar as dotstar import time dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: dot[0] = (255, 255, 0) time.sleep(0.5) dot[0] = (0, 0, 255) time.sleep(0.5) Notice that we on line 5 we call the dotstar dot, but to use it we say dot[0]. Dotstars and Neopixels are designed to be chained together on a strip with common wires, so dot actually refers to a list of LEDs, not just one. Counting in computers usually begins at zero, so the LED at the end closest to the signal source is numbered dot[0] and the others numbered dot[1], dot[2] and so on. Since there is only one built-in dotstar, we only use dot[0].\nRespond to the capacitive input You can use pin A2 as a capacitive input, meaning it will detect your finger touching it.\n1 2 3 4 5 6 7 8 9 10 11 import board import digitalio from touchio import TouchIn touch2 = TouchIn(board.A2) led = digitalio.DigitalInOut(board.D13) led.direction = digitalio.Direction.OUTPUT while True: led.value = touch2.value Capacitive input and the RGB LED If we want to control the RGB led with with the touch input, we need to do a bit more work, and use an if statement.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import board import adafruit_dotstar as dotstar from touchio import TouchIn touch2 = TouchIn(board.A2) dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: if touch2.value: dot[0] = (255, 255, 0) else: dot[0] = (0, 0, 255) ","categories":"","description":"","excerpt":"Let’s get something happening on your Gemma.\nAll of these examples are …","ref":"/7/gemma/03basics/circuitpython/","tags":"","title":"CircuitPython"},{"body":"You will need to submit your code for each activity to the hand-in system (only accessible from the school network).\nSequencing\nActivity 1.1, 1.2, 1.3, 1.4\nVariables and Lists\nActivity 2.1, 2.3, 2.2, 2.4, 2.5\nImage design template\nIteration and Selection\nActivity 3.1, 3.2, 3.3, 3.4\nAccelerometer\nActivity 4.1, 4.2, 4.3, 4.4, Extension\nMusic\nActivity 5.1, 5.2, 5.3, Extension\nNetworking\nActivity 6.1, 6.2, 6.3, 6.4, Extension\nWorking at home? Try the Microbit simulator at create.withcode.uk. Type your code in as usual (including the all important from microbit import * line), and then press the big play (▶) button in the bottom right to run it. ","categories":"","description":"","excerpt":"You will need to submit your code for each activity to the hand-in …","ref":"/7/microbit/tasks/","tags":"","title":"Task 1 - Algorithms and Coding"},{"body":"Embedded code like on a Gemma or Micro:bit often involves going around a main loop forever. We can’t use sleep/wait/delay functions because they’ll stop everything else from happening. We can use counters to make multiple actions seem to happen at once.\nHere is an example. In this case, you can see in the flowchart below that we will use a counter called n, and initialise it to 0. Each time around the loop we will check if n has reached 1000 yet. If it has we will reset it to 0. Otherwise, it will increment n (add 1 to it).\nflowchart LR a([Start]) b[Set n = 0] c[Switch light off] d{n == 1000?} e[Set n = 0] f[Flick switch] g[Increment n] a--\u003eb--\u003ec--\u003ed d--True--\u003ee--\u003ef--\u003ed d--False--\u003eg--\u003ed Here is the equivalent Python code to run on your Gemma. Note that this loop goes around 1000 times before it flicks the switch each time. Observe how fast the light is flashing; remember that computers are really, really, really, really fast!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import board import digitalio import time led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT n = 0 led.value = False while True: if n == 1000: n = 0 led.value = not led.value n += 1 A wild example Here is a crazier example with four counters, one each for the built-in led, and each of the red, green and blue channels of the dotstar.\nEach counter is reset and its respective switch “flicked” after a given amount of time. Try changing the counter values to make different patterns.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import board import digitalio import adafruit_dotstar as dotstar led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) ledCount = 0 led.value = False redCount = 0 redValue = 0 greenCount = 0 greenValue = 0 blueCount = 0 blueValue = 0 while True: if ledCount == 500: ledCount = 0 led.value = not led.value if redCount == 700: redCount = 0 redValue = 255 - redValue if greenCount == 900: greenCount = 0 greenValue = 255 - greenValue if blueCount == 1100: blueCount = 0 blueValue = 255 - blueValue ledCount += 1 redCount += 1 greenCount += 1 blueCount += 1 dot[0] = (redValue, greenValue, blueValue) ","categories":"","description":"","excerpt":"Embedded code like on a Gemma or Micro:bit often involves going around …","ref":"/7/gemma/03basics/counters/","tags":"","title":"Counters"},{"body":"Using the Microbit, make a Magic 8-ball by following steps 1-5 below.\nEnsure your app is working by carrying out testing and modifying your code. Include comments in your code and hand it in when finished.\nThe Magic 8-ball is a fortune telling toy created by Mattel in the 1950s. The concept is simple. Ask the 8-ball a yes or no question and the 8-ball will reply with answers such as “Yes”, “No”, “Without a doubt” etc. (seemingly able to predict the future). The Magic 8 Ball is made up of 20 responses — 10 positive, 5 negative and 5 neutral. The 20 answers are:\nPositive answers\nIt is certain It is decidedly so Without a doubt Yes definitely You may rely on it As I see it, yes Most likely Outlook good Yes Signs point to yes Negative answers\nDon’t count on it My reply is no My sources say no Outlook not so good Very doubtful Neutral answers\nReply hazy, try again Ask again later Better not tell you now Cannot predict now Concentrate and ask again According to Wikipedia “Using the coupon collector’s problem in probability theory, it can be shown that it takes, on average, 72 outcomes of the Magic 8 Ball for all 20 of its answers to appear at least once.”\n1: Write an ‘8’ to the screen In the Microbit app, write the following code:\nfrom microbit import * import random while True: sleep(1000) display.show(\"8\") Upload the code to the Microbit and run it. What happens when you shake the Microbit?\n2: Shake it! Add the following code to what you have already written, inside the while True:.\nif accelerometer.was_gesture(\"shake\"): display.clear() sleep(1000) display.show(\"!\") Upload the code to the Microbit and run it. What happens when you shake the Microbit?\n3: Write some responses We need to list our responses, and in Python we do that in a list variable. The list is Python’s equivalent to other languages’ array. Write this code before the while True:.\nanswers = [\"Yes\", \"No\", \"Maybe\", \"Yes, definitely\"] 4: Pick a random response To make the Magic 8-Ball pick a random response, we can get it to pick a random answer using random.choice().\nsleep(1000) display.scroll(random.choice(answers)) Include this code so that when you shake the Microbit, the microbit will wait a second and then show a random answer to the question you put to it.\n5: Modify and extend your code Modify your list to contain all 20 official responses.\nAdd comments to your code to explain how it works.\nModify your code so that it plays a sound when it gives a response.\nModify your code so that it counts how many responses and shows an image after 3 responses.\n","categories":"","description":"","excerpt":"Using the Microbit, make a Magic 8-ball by following steps 1-5 below. …","ref":"/7/microbit/magic8ball/","tags":"","title":"Task 3 - Magic 8-ball"},{"body":"Light sensor from microbit.org\nfrom microbit import * while True: if display.read_light_level() \u003e 100: display.show(Image( \"90909:\" \"09990:\" \"99999:\" \"09990:\" \"90909\")) else: display.clear() Max/min temperature recorder *from microbit.org\nfrom microbit import * currentTemp = temperature() max = currentTemp min = currentTemp while True: display.show('.') currentTemp = temperature() if currentTemp \u003c min: min = currentTemp if currentTemp \u003e max: max = currentTemp if button_a.was_pressed(): display.scroll(min) if button_b.was_pressed(): display.scroll(max) sleep(1000) display.clear() sleep(1000) Teleporting duck from microbit.org\nNote: The radio group is a number between 0 and 255. Microbits set to the same group can send and receive messages. Microbits set to different groups can’t share messages. In this example the group is set to 23, but you should change this value if someone else is using channel 23.\nfrom microbit import * import radio radio.config(group=23) radio.on() while True: message = radio.receive() if message: display.show(Image.DUCK) if accelerometer.was_gesture('shake'): display.clear() radio.send('duck') Compass For detecting strong magnetic fields, like those from a magnet you might use to stick something to the fridge, you do not need to calibrate the magnetometer (compass sensor). You do need to calibrate it to detect the relatively small magnetic field of the earth. The microbit will ask you to tilt it until all the display leds are lit.\nfrom microbit import * compass.calibrate() while True: bearing = compass.heading() if bearing \u003c 45 or bearing \u003e 315: display.show('N') else: display.show(' ') ","categories":"","description":"","excerpt":"Light sensor from microbit.org\nfrom microbit import * while True: if …","ref":"/7/microbit/extras/","tags":"","title":"Other things to try"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/gemma/","tags":"","title":"Gemma"},{"body":"The first project you do with any new piece of hardware: flash a light.\n1 2 3 4 5 6 7 8 9 10 11 12 13 from digitalio import DigitalInOut, Direction import board import time # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT while True: led.value = True time.sleep(0.5) led.value = False time.sleep(0.5) ","categories":"","description":"","excerpt":"The first project you do with any new piece of hardware: flash a …","ref":"/7/gemma/02examples/flash/","tags":"","title":"Flash a light"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/gemma/01gettingstarted/","tags":"","title":"Getting started"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/gemma/02examples/","tags":"","title":"Examples"},{"body":"In this example, the light will turn on while you touch pin A2.\nfrom digitalio import DigitalInOut, Direction from touchio import TouchIn import board import time # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT # Capacitive touch on A2 touch2 = TouchIn(board.A2) while True: led.value = touch2.value ","categories":"","description":"","excerpt":"In this example, the light will turn on while you touch pin A2.\nfrom …","ref":"/7/gemma/02examples/respond/","tags":"","title":"Respond to input"},{"body":"The Gemma has a built-in (DotStar) RGB LED. DotStar LEDs can be chained together, and even though there is only one on the Gemma, we still refer to it as though it were on a chain, just a chain of one. Colors are set with an RGB tuple. The brightness can be configured between 0 and 1. Why would you want to lower the brightness? Here are three reasons:\nmaximum brightness is almost painfully bright, which is bad if you’re up close. at night, a little light goes a long way, and you may not need a simple notification to double as a torch. the brighter it is, the more power it draws, which is a problem for battery powered projects where you want to maximise battery life. import adafruit_dotstar as dotstar import board import time # Configure the DotStar LED, and call it \"dot\" dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) while True: dot[0] = (255, 0, 0) time.sleep(0.5) dot[0] = (0, 255, 0) time.sleep(0.5) dot[0] = (0, 0, 255) time.sleep(0.5) ","categories":"","description":"","excerpt":"The Gemma has a built-in (DotStar) RGB LED. DotStar LEDs can be …","ref":"/7/gemma/02examples/color/","tags":"","title":"A flash of colo(u)r"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/gemma/03basics/","tags":"","title":"Learning the basics"},{"body":"The demo program that comes with the Gemma includes a nice function which generates a swirl through the rainbow. It takes a number from 0-255 and returns a color as a list (which you can use directly instead of specific color tuple).\n# Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos \u003c 0: return [0, 0, 0] if pos \u003e 255: return [0, 0, 0] if pos \u003c 85: return [int(255 - pos*3), int(pos*3), 0] elif pos \u003c 170: pos -= 85 return [0, int(255 - (pos*3)), int(pos * 3)] else: pos -= 170 return [int(pos*3), 0, int(255 - pos*3)] Here is a complete example of it in action, using the built-in DotStar.\nimport adafruit_dotstar as dotstar import board import time # One pixel connected internally! dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) # Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos \u003c 0: return [0, 0, 0] if pos \u003e 255: return [0, 0, 0] if pos \u003c 85: return [int(255 - pos*3), int(pos*3), 0] elif pos \u003c 170: pos -= 85 return [0, int(255 - (pos*3)), int(pos * 3)] else: pos -= 170 return [int(pos*3), 0, int(255 - pos*3)] color = 0 t = 0 while True: dot[0] = wheel(color) t +=1 if t == 10: t = 0 color += 1 if color == 256: color = 0 ","categories":"","description":"","excerpt":"The demo program that comes with the Gemma includes a nice function …","ref":"/7/gemma/02examples/colorwheel/","tags":"","title":"Color cycling"},{"body":"# Welcome to CircuitPython 5 :) import usb_hid from adafruit_hid.keyboard import Keyboard from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS from adafruit_hid.keycode import Keycode from touchio import TouchIn import board import time # Capacitive touch on A2 touch0 = TouchIn(board.A0) touch1 = TouchIn(board.A1) touch2 = TouchIn(board.A2) # The keyboard object! Used if we do HID output, see below time.sleep(1) # Sleep for a bit to avoid a race condition on some systems keyboard = Keyboard(usb_hid.devices) layout = KeyboardLayoutUS(keyboard) # We're in the US :) ######################### MAIN LOOP ############################## while True: if touch0.value: keyboard.send(Keycode.CTRL, Keycode.N) keyboard.send(Keycode.CTRL, Keycode.A) layout.write(\"This is my computer now...\") time.sleep(1) keyboard.send(Keycode.WINDOWS, Keycode.L) if touch1.value: keyboard.send(Keycode.F11) if touch2.value: keyboard.send(Keycode.NINE) ","categories":"","description":"","excerpt":"# Welcome to CircuitPython 5 :) import usb_hid from …","ref":"/7/gemma/02examples/touchkeyboard/","tags":"","title":"Touch keyboard"},{"body":" 1 2 3 4 5 6 7 8 9 10 11 12 import board import time import neopixel # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) while True: pixels[0] = (255, 0, 0, 0) pixels[1] = (0, 255, 255, 0) pixels[2] = (0, 0, 0, 255) ","categories":"","description":"","excerpt":" 1 2 3 4 5 6 7 8 9 10 11 12 import board import time import neopixel # …","ref":"/7/gemma/02examples/neopixels/","tags":"","title":"Neopixels"},{"body":"Let’s improve our code so now the lights respond to touch input.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import board import time import neopixel from touchio import TouchIn touch = TouchIn(board.A2) # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) while True: if touch.value: pixels[0] = (255, 0, 0, 0) pixels[1] = (0, 255, 255, 0) pixels[2] = (0, 0, 0, 255) else: pixels.fill((0, 0, 0, 0)) ","categories":"","description":"","excerpt":"Let’s improve our code so now the lights respond to touch input.\n1 2 3 …","ref":"/7/gemma/02examples/neopixels2/","tags":"","title":"Neopixels (Part 2)"},{"body":"At the moment, we need to hold down the touch pad to keep the lights on—hardly a useful feature for a lamp! Let’s change that so that touching the touch pad changes the light from off to on, and back again.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import board import time import neopixel from touchio import TouchIn touch = TouchIn(board.A2) # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) on = False while True: if touch.value: on = not on if on: pixels[0] = (255, 0, 0, 0) pixels[1] = (0, 255, 255, 0) pixels[2] = (0, 0, 0, 255) else: pixels.fill((0, 0, 0, 0)) ","categories":"","description":"","excerpt":"At the moment, we need to hold down the touch pad to keep the lights …","ref":"/7/gemma/02examples/neopixels3/","tags":"","title":"Neopixels (Part 3)"},{"body":"In part 3 we added a touch switch, but the processor in Gemma is so fast compared with our finger movements that it is nearly impossible to reliably turn it on or off. Let’s force the processor to wait until we’ve taken our finger off the touch switch before continuing, thus ensuring each touch registers only once.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import board import time import neopixel from touchio import TouchIn touch = TouchIn(board.A2) # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) on = False while True: if touch.value: on = not on while touch.value: pass if on: pixels[0] = (255, 0, 0, 0) pixels[1] = (0, 255, 255, 0) pixels[2] = (0, 0, 0, 255) else: pixels.fill((0, 0, 0, 0)) ","categories":"","description":"","excerpt":"In part 3 we added a touch switch, but the processor in Gemma is so …","ref":"/7/gemma/02examples/neopixels4/","tags":"","title":"Neopixels (Part 4)"},{"body":"In part 4 we fixed the switching behaviour. Now let’s add some rainbow colour changing to our lights.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import board import time import neopixel from touchio import TouchIn touch = TouchIn(board.A2) # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u003c 0): return [0, 0, 0] if (pos \u003e 255): return [0, 0, 0] if (pos \u003c 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u003c 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] on = False i = 0 while True: if touch.value: on = not on while touch.value: pass if on: pixels[0] = wheel(i) pixels[1] = (0, 255, 255, 0) pixels[2] = (0, 0, 0, 255) else: pixels.fill((0, 0, 0, 0)) i = (i+1) % 256 ","categories":"","description":"","excerpt":"In part 4 we fixed the switching behaviour. Now let’s add some rainbow …","ref":"/7/gemma/02examples/neopixels5/","tags":"","title":"Neopixels (Part 5)"},{"body":"If you hold your finger down while the lights are on, the rainbow stops cycling. This is slightly disappointing. Let’s fix that, and at the same time prepare ourselves so we can have short presses and long presses.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import board import time import neopixel from touchio import TouchIn touch = TouchIn(board.A2) # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u003c 0): return [0, 0, 0] if (pos \u003e 255): return [0, 0, 0] if (pos \u003c 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u003c 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] pressTime = 0 on = False i = 0 while True: if touch.value and pressTime == 0: pressTime = time.monotonic() if not touch.value and pressTime != 0: holdTime = time.monotonic()-pressTime pressTime = 0 if holdTime \u003e 1: on = not on if on: pixels[0] = wheel(i) pixels[1] = (0, 255, 255, 0) pixels[2] = (0, 0, 0, 255) else: pixels.fill((0, 0, 0, 0)) i = (i+1) % 256 ","categories":"","description":"","excerpt":"If you hold your finger down while the lights are on, the rainbow …","ref":"/7/gemma/02examples/neopixels6/","tags":"","title":"Neopixels (Part 6)"},{"body":"Let’s setup a list of colours for the other two lights to cycle through. We’ll also set up a variable that reminds us where in the cycle of colours we’re up to (like you might use your finger to keep track of which line you’re on when reading).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import board import time import neopixel from touchio import TouchIn touch = TouchIn(board.A2) # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u003c 0): return [0, 0, 0] if (pos \u003e 255): return [0, 0, 0] if (pos \u003c 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u003c 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] colors = [ (255, 0, 0, 0), (255, 255, 0, 0), (0, 255, 0, 0), (0, 255, 255, 0), (0, 0, 255, 0), (255, 0, 255, 0), (255, 255, 255, 0), (0, 0, 0, 255), (0, 0, 0, 0) ] colorIndex = 0 pressTime = 0 on = False i = 0 while True: if touch.value and pressTime == 0: pressTime = time.monotonic() if not touch.value and pressTime != 0: holdTime = time.monotonic()-pressTime pressTime = 0 if holdTime \u003e 1: on = not on else: colorIndex = (colorIndex+1) % len(colors) if on: pixels[0] = wheel(i) pixels[1] = colors[colorIndex] pixels[2] = colors[colorIndex] else: pixels.fill((0, 0, 0, 0)) i = (i+1) % 256 ","categories":"","description":"","excerpt":"Let’s setup a list of colours for the other two lights to cycle …","ref":"/7/gemma/02examples/neopixels7/","tags":"","title":"Neopixels (Part 7)"},{"body":"from analogio import AnalogIn, AnalogOut import adafruit_dotstar as dotstar import board import time # One pixel connected internally! dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2, auto_write=True) # Analog input on A1 photocell = AnalogIn(board.A1) while True: print(photocell.value) time.sleep(0.1) if photocell.value \u003e 300: dot[0] = (255, 255, 255) else: dot[0] = (100, 0, 0) ","categories":"","description":"","excerpt":"from analogio import AnalogIn, AnalogOut import adafruit_dotstar as …","ref":"/7/gemma/02examples/photocell/","tags":"","title":"Photocell"},{"body":"import time import neopixel import adafruit_dotstar import pulseio from analogio import AnalogIn import board def get_voltage(pin): return (pin.value * 3.3) / 65536 pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) vibrationPin = AnalogIn(board.A0) while True: vibration = get_voltage(vibrationPin) print(vibration) time.sleep(.1) if vibration \u003c 0.81: # the sensor has been tripped, adjust this value pixels[0] = (255, 0, 0, 0) time.sleep(0.5) else: pixels[0] = (0, 255, 0, 0) pixels.fill(OFF) ","categories":"","description":"","excerpt":"import time import neopixel import adafruit_dotstar import pulseio …","ref":"/7/gemma/02examples/vibration/","tags":"","title":"Vibration Sensor"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/glossary/","tags":"","title":"Glossary"},{"body":"Let’s set up a list of colours for the three lights to cycle through. The first entry in the list will be ignored, and we’ll show cycling rainbows instead, so we’ll leave that dummy entry as black (all zero).\nWe’ll use the light sensor to decide whether to turn the lights on or off, and an available input as a touch sensor to change the colours.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import board import time import neopixel from touchio import TouchIn from analogio import AnalogIn, AnalogOut touch = TouchIn(board.A2) # Analog input on A1 photocell = AnalogIn(board.A1) # LED strip pixels = neopixel.NeoPixel(board.D1, 3, brightness=1, auto_write=True, pixel_order=neopixel.GRBW) def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u003c 0): return [0, 0, 0] if (pos \u003e 255): return [0, 0, 0] if (pos \u003c 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u003c 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] colors = [ (0, 0, 0, 0), (255, 0, 0, 0), (255, 255, 0, 0), (0, 255, 0, 0), (0, 255, 255, 0), (0, 0, 255, 0), (255, 0, 255, 0), (255, 255, 255, 0), (0, 0, 0, 255) ] colorIndex = 0 pressTime = 0 on = False i = 0 brightness = photocell.value while True: if touch.value: colorIndex = (colorIndex+1) % len(colors) while touch.value: pass if i == 0: # only check the brightness every 256 loops # to avoid weird flashing effect brightness = photocell.value print(photocell.value) if brightness \u003e 300: # It's dark. Turn the lights on! if colorIndex == 0: # Dummy colors. Show rainbow pixels.fill(wheel(i)) else: # Show the current colors pixels.fill(colors[colorIndex]) if brightness \u003c 150: # It's light. Turn the lights off pixels.fill((0, 0, 0, 0)) i = (i+1) % 256 ","categories":"","description":"","excerpt":"Let’s set up a list of colours for the three lights to cycle through. …","ref":"/7/gemma/02examples/alltogether/","tags":"","title":"Everything together"},{"body":" Version 2.2.4 5 ```python # Gemma IO demo # Welcome to CircuitPython 2.2.4 :) from adafruit_hid.keyboard import Keyboard from adafruit_hid.keycode import Keycode from digitalio import DigitalInOut, Direction, Pull from analogio import AnalogIn, AnalogOut from touchio import TouchIn import adafruit_dotstar as dotstar import microcontroller import board import time # One pixel connected internally! dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT # Analog output on A0 aout = AnalogOut(board.A0) # Analog input on A1 analog1in = AnalogIn(board.A1) # Capacitive touch on A2 touch2 = TouchIn(board.A2) # Used if we do HID output, see below kbd = Keyboard() ######################### HELPERS ############################## # Helper to convert analog input to voltage def getVoltage(pin): return (pin.value * 3.3) / 65536 # Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u003c 0): return [0, 0, 0] if (pos \u003e 255): return [0, 0, 0] if (pos \u003c 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u003c 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] ######################### MAIN LOOP ############################## i = 0 while True: # spin internal LED around! dot[0] = wheel(i) dot.show() # set analog output to 0-3.3V (0-65535 in increments) aout.value = i * 256 # once every 256 ticks, so it doesnt rush by! if i == 0: # Read analog voltage on A1 print(\"A1: %0.2f\" % getVoltage(analog1in)) # Print the temperature print(\"Temp: %0.1f\" % microcontroller.cpu.temperature) # use A2 as capacitive touch to turn on internal LED if touch2.value: print(\"A2 touched!\") # optional! uncomment below \u0026 save to have it sent a keypress #kbd.press(Keycode.A) #kbd.release_all() led.value = touch2.value i = (i+1) % 256 # run from 0 to 255 ``` ```python # Gemma IO demo # Welcome to CircuitPython 5 :) import usb_hid from adafruit_hid.keyboard import Keyboard from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS from adafruit_hid.keycode import Keycode from digitalio import DigitalInOut, Direction, Pull from analogio import AnalogIn, AnalogOut from touchio import TouchIn import adafruit_dotstar as dotstar import microcontroller import board import time # One pixel connected internally! dot = dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1, brightness=0.2) # Built in red LED led = DigitalInOut(board.D13) led.direction = Direction.OUTPUT # Analog output on A0 aout = AnalogOut(board.A0) # Analog input on A1 analog1in = AnalogIn(board.A1) # Capacitive touch on A2 touch2 = TouchIn(board.A2) # The keyboard object! Used if we do HID output, see below time.sleep(1) # Sleep for a bit to avoid a race condition on some systems keyboard = Keyboard(usb_hid.devices) keyboard_layout = KeyboardLayoutUS(keyboard) # We're in the US :) ######################### HELPERS ############################## # Helper to convert analog input to voltage def getVoltage(pin): return (pin.value * 3.3) / 65536 # Helper to give us a nice color swirl def wheel(pos): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if (pos \u003c 0): return [0, 0, 0] if (pos \u003e 255): return [0, 0, 0] if (pos \u003c 85): return [int(pos * 3), int(255 - (pos*3)), 0] elif (pos \u003c 170): pos -= 85 return [int(255 - pos*3), 0, int(pos*3)] else: pos -= 170 return [0, int(pos*3), int(255 - pos*3)] ######################### MAIN LOOP ############################## i = 0 while True: # spin internal LED around! dot[0] = wheel(i) dot.show() # set analog output to 0-3.3V (0-65535 in increments) aout.value = i * 256 # once every 256 ticks, so it doesnt rush by! if i == 0: # Read analog voltage on A1 print(\"A1: %0.2f\" % getVoltage(analog1in)) # Print the temperature print(\"Temp: %0.1f\" % microcontroller.cpu.temperature) # use A2 as capacitive touch to turn on internal LED if touch2.value: print(\"A2 touched!\") # optional! uncomment below \u0026 save to have it sent a keypress #keyboard.press(Keycode.A) #keyboard.release_all() led.value = touch2.value i = (i+1) % 256 # run from 0 to 255 ``` ","categories":"","description":"","excerpt":" Version 2.2.4 5 ```python # Gemma IO demo # Welcome to CircuitPython …","ref":"/7/gemma/02examples/builtindemo/","tags":"","title":"Built-in example"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/gemma/03basics/combiningcode/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/gemma/projectideas/bikelight/","tags":"","title":""},{"body":"Purpose To develop your Computational Thinking skills by solving a variety of real world problems using the Micro:bit and Python code with branching and iterations.\nLearning Behaviours This task provides the following opportunities to develop and demonstrate the Learner Behaviours:\nLB Description Driven Engages in Python coding challenges with persistence and learns from their mistakes and willingly completes the extension activities. Curious Explores and tests ideas by asking questions, researching and through trial and error when learning new skills or developing solutions Collaborators Works in teams to solve problems and create new information. Willingly shares new skills and knowledge and assists others and seeks assistance from peers. Connected Connects programming constructs and data structures to real life applications and is able to explore and discuss issues and ethical implications of their solution Flexible Thinkers Applies new knowledge and skills to solve problems and is able to adapt and recognize patterns in other solutions Disciplined Motivated learner who demonstrates initiative by following a project management process to complete a project Task Description Students work through a series of tasks introducing them to sequencing, debugging, output, variables, lists, selection and iteration while using MicroPython and the BBC micro: bit. Students develop their Computational Thinking skills designing, implementing and evaluating algorithms.\nSection 1. Sequencing 1.1 1.2 1.3 1.4 2. Variables and Lists 2.1 2.2 2.3 2.4 2.5 Image design template 3. Iteration and Selection 3.1 3.2 3.3 3.4 4. Accelerometer 4.1 4.2 4.3 4.4 Ext 5. Music 5.1 5.2 5.3 Ext 6. Networking 6.1 6.2 6.3 6.4 Ext To be successful Accurately and independently complete all 6 modules Include your code and output for each exercise in your OneNote section called Task 1 Folio Algorithms and coding. Include comments with your all Python code Use the correct programming structure (selection and iteration) Complete core and attempt any extension exercises\nWorking at home? Try the Microbit simulator at create.withcode.uk. Type your code in as usual (including the all important from microbit import * line), and then press the big play (▶) button in the bottom right to run it. ","categories":"","description":"","excerpt":"Purpose To develop your Computational Thinking skills by solving a …","ref":"/7/assessment/microbit/1-folio/","tags":"","title":"1: Folio"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/microbit/2-quiz/","tags":"","title":"2: Quiz"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/microbit/3-magic8ball/","tags":"","title":"3: Magic 8-ball"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/networks/4-investigation/","tags":"","title":"4: Investigation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/networks/5-socials/","tags":"","title":"5: Social Media"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/algorithms/6-algorithms/","tags":"","title":"6: Algorithms"},{"body":" Year 7 Digital Technologies at Thomas More College Assessment Micro:bit Networks Algorithms Gemma ","categories":"","description":"","excerpt":" Year 7 Digital Technologies at Thomas More College Assessment …","ref":"/7/","tags":"","title":"7 Digital Tech"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/gemma/7-project/","tags":"","title":"7: Digital Project"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/algorithms/","tags":"","title":"Algorithms"},{"body":"When calling a function, the values given to it are called arguments. For example, in this case:\ntotal = add(3, 4) 3 and 4 are arguments to the function add().\nWhen defining a function, the pieces of information that the function takes to do its job are called parameters.\n","categories":"","description":"","excerpt":"When calling a function, the values given to it are called arguments. …","ref":"/7/glossary/argument/","tags":"","title":"argument"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/","tags":"","title":"Assessment"},{"body":"In almost all programming, American spellings are used. So as programmers we use colors, even though we would normally spell the word colours.\nColors are described by the amount of red, green, and blue light to emit, using numbers in the range 0 to 255. In Python, we list these as a tuple (red, green, blue), such as:\n(0, 150, 255) The built-in RGB LED on your Gemma (a DotStar) has these three color components, so we set its color in this way.\nThe NeoPixel RGB LEDs you will solder onto your Gemma have four components: the usual red, green, and blue and also white. So you if you wanted the above color on your Neopixel LED strip, you would use:\n(0, 150, 255, 0) Unless you want to set a particular LED pixel to be white in color, it is recommended that you set the white value to zero (0), as the white tends to wash out the colors otherwise.\nYou can use the Google Color Picker to find different colors, and then copy the RGB value listed. Don’t forget to add a value for the white (probably zero) after the other three numbers, if you are setting NeoPixel colors.\n","categories":"","description":"","excerpt":"In almost all programming, American spellings are used. So as …","ref":"/7/glossary/color/","tags":"","title":"color/colour"},{"body":"[TIP] This is a tip!\nimport time import neopixel import adafruit_dotstar import pulseio from analogio import AnalogIn import board pixpin = board.D0 numpix = 3 pixels = neopixel.NeoPixel(pixpin, numpix, brightness = 0.5, auto_write=True, pixel_order=neopixel.GRBW) dotstar = adafruit_dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1) vibrationPin = AnalogIn(board.A0) def get_voltage(pin): return (pin.value * 3.3) / 65536 # Named colours RED = (255, 0 , 0, 0) BLUE = (0, 0, 255, 0) GREEN = (0, 255, 0, 0) OFF = (0, 0, 0, 0) # List of colours to cycle through colours = [RED, GREEN, BLUE, (255,0,255)] # Index of which colour in the list we're on coloursIndex = 0 # Timer for when to print the vibration sensor value printTimer = 0 # Timer to make sure that we wait # for one vibration to have stopped # before we check for the next debounce = 0 # Timer for changing colours if we're on colourTimer = 0 # Whether the light is on or not on = False # Turn lights off to start pixels.fill((0,0,0,0)) while True: dotstar[0] = (0,0,printTimer) vibration = get_voltage(vibrationPin) # Check the timers and reset them if they've gone off if printTimer == 0: printTimer = 255 print(vibration) if colourTimer == 0: colourTimer = 255 coloursIndex = (coloursIndex + 1)%len(colours) if on: pixels.fill(colours[coloursIndex]) else: pixels.fill(OFF) if debounce == 0 and vibration \u003c 0.8: debounce = 255 print(vibration) on = not on if on: pixels.fill(colours[coloursIndex]) else: pixels.fill(OFF) printTimer -= 1 colourTimer -= 1 debounce -= 1 if debounce \u003c 0: debounce = 0 ","categories":"","description":"","excerpt":"[TIP] This is a tip!\nimport time import neopixel import …","ref":"/7/gemma/projectideas/cyclingcolours/","tags":"","title":"Cycling colours"},{"body":"Importing is the process of adding functions from additional libraries to support your program.\nImagine we wish to use the randint() function to choose a random number between 1 and 6, as though we were throwing a single six-sided die.\nThe randint() function is included in the random library, but there are three ways we can import it, and each has its attractions.\nimport 1 2 3 4 import random num = random.randint(1,6) print(num) import as 1 2 3 4 import random as ran num = ran.randint(1,6) print(num) import from 1 2 3 4 from random import randint num = randint(1,6) print(num) ","categories":"","description":"","excerpt":"Importing is the process of adding functions from additional libraries …","ref":"/7/glossary/import/","tags":"","title":"import"},{"body":"A list is a data structure for storing a series of related pieces of information.\nDefining a list You can define a list using square brackets, with the elements separated by commas, like this:\nsquares = [0, 1, 4, 9, 16, 25, 36] vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"] Selecting elements You can pick an element from the list like this: squares[0]. Note that counting begins at zero. Think of the number as “how far from the beginning” the element in the list is. So vowels[0] is the element at the start of the list, and vowels[3] is three elements further down the list. So the string \"u\" in that list would be vowels[4].\nAdding elements You can add elements to the end of a list with the append() function.\nsquares.append(49) print(squares[7]) # Output: 49 Removing elements You can remove elements from a list with remove() and pop().\nfriends = [\"Nhi\", \"David\", \"Hari\", \"Zahra\"] friends.remove(\"David\") print(friends) # Output: [\"Nhi, \"Hari\", \"Zahra\"] If there are multiple elements in the list with the same value, remove() will remove just the first one.\nfriends = [\"Nhi\", \"David\", \"Hari\", \"Zahra\"] exBestie = friends.pop(0) print(friends) # Output: [\"David\", \"Hari\", \"Zahra\"] print(exBestie) # Output: \"Nhi\" ","categories":"","description":"","excerpt":"A list is a data structure for storing a series of related pieces of …","ref":"/7/glossary/list/","tags":"","title":"list"},{"body":"\n","categories":"","description":"","excerpt":"\n","ref":"/7/microbit/","tags":"","title":"Micro:bit"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/microbit/","tags":"","title":"Microbit"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/networks/","tags":"","title":"Networks"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/assessment/networks/","tags":"","title":"Networks \u0026 Security"},{"body":"This example shows the basics of a state machine, also known by the more technical term finite state automaton. The idea is that the program is in a particular state, and certain events will cause a transition to another state.\nIn our case, our light is either on or off (the states), and we will transition between them with a big enough vibration reading. Here is a state diagram of this:\nstateDiagram-v2 direction LR [*] --\u003e Off Off --\u003e On : if vibration \u003c 0.80 and ready On --\u003e Off : if vibration \u003c 0.80 and ready Note the “and ready” condition. Given how fast the computer is, when we tap the light, the vibration value will be less than 0.80 for many cycles of the event loop, and without some care our light will flash on and off rapidly, and be unpredictable.\nHere is the complete code with several comments included. We’ll break it down below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 # Import libraries import time import neopixel import adafruit_dotstar import pulseio from analogio import AnalogIn import board # Set up neopixel light strip pixpin = board.D0 numpix = 3 pixels = neopixel.NeoPixel(pixpin, numpix, brightness = 0.5, auto_write=True, pixel_order=neopixel.GRBW) # Built-in RGB light dotstar = adafruit_dotstar.DotStar(board.APA102_SCK, board.APA102_MOSI, 1) vibrationPin = AnalogIn(board.A0) def get_voltage(pin): return (pin.value * 3.3) / 65536 # A list of all the states, each uniquely numbered # (not important what the numbers are, # as long as they're unique) OFF = 0 ON = 1 # Variable to keep track of which state we're in. state = OFF # Flag to keep track of whether we're \"ready\" or not ready = True # Counter to keep track of when the ready flag should be set readyCounter = 0 # Counter to print vibration value printCounter = 0 # Event loop while True: vibration = get_voltage(vibrationPin) # Do code matching the current state, whether OFF or ON if state == OFF: # ensure light off pixels.fill((0, 0, 0, 0)) # check for events which cause transition from this state if vibration \u003c 0.8 and ready: # do anything we need to exit this state # change state for next iteration of the loop state = ON # do anything we need to enter new state # Make us not ready, and set the ready counter ready = False readyCounter = 100 elif state == ON: # ensure light on pixels[0] = (255, 0, 0, 0) pixels[1] = (0, 255, 0, 0) pixels[2] = (0, 0, 255, 0) # check for events if vibration \u003c 0.8 and ready: state = OFF ready = False readyCounter = 100 # Handle the counters if readyCounter \u003e 0: # Decrement the counter readyCounter -= 1 # If zero, we're \"ready\" if readyCounter == 0: ready = True if printCounter == 0: print(state, ready, vibration) printCounter = (printCounter + 1) % 10 ","categories":"","description":"","excerpt":"This example shows the basics of a state machine, also known by the …","ref":"/7/gemma/projectideas/onofflamp/","tags":"","title":"On-off lamp"},{"body":"When defining a function, the pieces of information that the function takes to do its job are called parameters. For example, here:\ndef add(first, second): return first + second first and second are the parameters of the function add().\nWhen calling a function, the values given to it are called arguments.\n","categories":"","description":"","excerpt":"When defining a function, the pieces of information that the function …","ref":"/7/glossary/parameter/","tags":"","title":"parameter"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/gemma/projectideas/","tags":"","title":"Project ideas"},{"body":"","categories":"","description":"","excerpt":"","ref":"/7/search/","tags":"","title":"Search Results"},{"body":"To program you Gemma M0 or other CircuitPython compatible hardware, you will need to either:\nuse Mu, or use another editor Mu is set up to be very helpful for beginners. It has some keyboard shortcuts, good help text, nice shortcut buttons, and is generally very friendly to use and has a lot of features to help beginners get started. It also includes a Serial Monitor, meaning Mu will automatically display information sent back from your Gemma.\nAfter you have been writing code for a while, you may find that a more powerful text editor like Visual Studio Code allows you a lot more power and flexibility, at the cost of complexity, and possibly doing some more basic things yourself.\nUsing Mu Install Mu, using the Company Portal (on a school computer), or from the website.\nTo program your Gemma M0, make sure you select the mode CircuitPython (depending on your version, it may be called something slightly different, but it is the mode with ‘CircuitPython’ somewhere in the title).\nUsing Visual Studio Code Install Visual Studio Code from the Company Portal (on a school computer), or from the website.\n","categories":"","description":"","excerpt":"To program you Gemma M0 or other CircuitPython compatible hardware, …","ref":"/7/gemma/01gettingstarted/installation/","tags":"","title":"Software"},{"body":"When you plug your Gemma in to your computer, it will appear as a USB drive (probably D:, unless you’ve got something else already plugged in). If you open the Gemma, you’ll see a file called code.py or main.py. This is the file that your Gemma will run. To change the program your Gemma is running, just edit this file!\nD:/ ├── code.py # on newer versions ├── main.py # on older versions │ └── lib/ └── ... # library files, which tell the software how to control hardware we might connect ","categories":"","description":"","excerpt":"When you plug your Gemma in to your computer, it will appear as a USB …","ref":"/7/gemma/01gettingstarted/filestructure/","tags":"","title":"Structuring your files"},{"body":"A tuple is a single unit of data made up of multiple values. In Python they are defined using round brackets, with commas separating the values. Tuples can contain all sorts of data as values, but when programming Gemma we mostly use them for colors (red, green, blue, white).\n","categories":"","description":"","excerpt":"A tuple is a single unit of data made up of multiple values. In Python …","ref":"/7/glossary/tuple/","tags":"","title":"tuple"},{"body":"Computers store all information as sequences of numbers, but different kinds of data are encoded in different ways. For example, whole numbers and decimal numbers are stored differently.\nSome common data types you’ll encounter are:\nintegers (int) Integers are whole numbers, and can be positive or negative. floating point numbers (float and double) Floating point numbers (commonly called floats) are for storing decimal numbers. The number is stored in scientific notation, with a mantissa and exponent. $$\\overbrace{3.18}^{\\text{mantissa}}\\times 10^{\\overbrace{-7}^{\\text{exponent}}}$$ There is a limited number of digits for the mantissa and the exponent. If you need more, a double precision floating point number (or double for short) has twice the space, so can store a more precise mantissa, and a larger exponent.\ncharacters (char) A character is a single letter, digit, punctuation mark, or piece of whitespace (a space, newline, tab, etc.). strings (string) Strings are so called because they are ‘strings of characters’. They are usually indicated with double quotes “like this”. In some languages, like Python, strings can be in single quotes as well, ’like this’. ","categories":"","description":"","excerpt":"Computers store all information as sequences of numbers, but different …","ref":"/7/glossary/type/","tags":"","title":"type"},{"body":"A variable is a named place to store a piece of information.\n","categories":"","description":"","excerpt":"A variable is a named place to store a piece of information.\n","ref":"/7/glossary/variable/","tags":"","title":"variable"}]